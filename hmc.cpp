/******************************************************************************

hamiltonian Monte Carlo Simulation For Guassian
*******************************************************************************/

#include <iostream>
#include <math.h>
#include <stdlib.h>
#include <fstream>
#include <iomanip>
#include <stdio.h>
#include <cstdlib> //seed and random number
#include<random>
using namespace std;

void srand48(long seedval) {
    srand(seedval);
}
long lrand48() {
    return rand();
}
double drand48() {
    return rand() / (double)RAND_MAX;
}

const int SWEEPS =100000;
const int L = 12;   // no. of steps
const double EPS =1;  //step size

//Functions defined
double gauss(void);
double action(const double);
double hamiltonian(const double,const double);
double force(const double);
int evolve(double&,double&,double&);    //Function can change the value of the passed parameter
int main()
{   
    double p = gauss();
   cout<< p;
  double seed ; //seed is a number or other value that is generated by software using one or more values
  seed = 41;
  cout <<"Using random seed:"<<seed <<endl;
  
  //Initialize random seed
  
  srand48(seed); //sets the seed for the random() function.
  
  double phi;
  double phi_old;
  double H_i ,H_f ,r , phi_sq;
  double dH,expmdH;
  int sweep ,count =0,accept = 0;
  
  double obs1=0 ,obs1_e =0.0,std_err_obs1=0.0;
  double obs2=0 ,obs2_e =0.0,std_err_obs2=0.0;
  
  double acc_rate =0.0, avg_acc_rate = 0.0, total_acc_rate = 0.0;
  double tot_count;
  
  //Initial Configuration for Phi
  phi = 2.0;
  static int first_time = 1;
  static ofstream f_obs;
  
  if(first_time)
  {
      f_obs.open("HMC.txt");
      if(f_obs.bad())
      {
          cout<< "Failed to open observable file\n"<<flush;
      }
      first_time =0 ;
  }
  
  phi_sq = 0.0;
  
  for(sweep = 0 ; sweep!= SWEEPS; sweep++)
  {
      phi_old = phi;
      evolve(phi,H_i,H_f);
      
      r =drand48();
      dH = H_f - H_i;
      expmdH = exp(-dH);
      
      if (expmdH > r)
      {
        
        accept++ ; //proposed state is accepted
      }
      else
      {
          phi = phi_old; // proposed states rejected
      }
      count++;
      
      if (count%100 ==0)
      {
          acc_rate =double(accept)/count;           //accepted state ./. proposed state
        //cout<<"acceptance rate ="<<acc_rate<<endl;
        total_acc_rate =total_acc_rate+acc_rate;        // adding all acceptance rates
      
        tot_count++;                        // total number of counts, No. of time loop runs
        count= 0;
        accept =0;
      }
      
      //phi Square
      phi_sq =phi*phi;
      obs1_e =obs1_e +phi*phi;      // [x] & [X^2]
      obs2 =obs2 +phi_sq;
      obs2_e =obs2_e + phi_sq*phi_sq;
      
      //write out phi ,phi^2 ,exp(-dH) in a file
      f_obs<< sweep<<"\t"<<phi<<"\t"<<phi_sq<<"\t"<<expmdH<<endl;
      
  }
  
  avg_acc_rate =total_acc_rate/tot_count;
  
  obs1= obs1/SWEEPS;
  obs1_e =obs1_e/SWEEPS;
  
  obs2 = obs2 /SWEEPS;
  obs2_e = obs2_e /SWEEPS;
  
  //Standard Error ?
  std_err_obs1 = sqrt((obs1_e - pow(obs1,2))/SWEEPS);
  std_err_obs2 = sqrt((obs2_e - pow(obs2,2))/SWEEPS);
  
  cout << "\n step size & average acceptance rate : " << endl ;
  cout << EPS << "\t " << avg_acc_rate<< endl ;
  cout << "\nphi and error : " << endl ;
  cout << obs1 << "\t " << std_err_obs1 << "\n" << endl ;
  cout << "\nphi_sq and error : " << endl ;
  cout << obs2 << "\t " << std_err_obs2<< "\n" << endl ;
    return 0;
}

//Gauss Random -------------------------------
double gauss(void) // function kind of
{
    static int iset =0;
    static double gset;
    double fac, rsq ,v1 ,v2;
    if (iset ==0)
    {
        do
        {
            v1 = 2.0*rand()/(double)RAND_MAX -1.0;
            v2 = 2.0*rand()/(double)RAND_MAX -1.0;
            rsq = v1*v1 + v2*v2;
        }
        while(rsq>=1.0 || rsq == 0.0);
        
        fac =sqrt(-2.0*log(rsq)/rsq);
        gset=v1*fac;
        iset =1;
        return(v2*fac);
        
    }
    else
    {
        iset = 0;
        return(gset);
    }
}

// Action S -------------------------------
double action(const double phi)
{
    double S =0.5*phi*phi;          //form of the Action 
    return S;
}

//Hamiltonian ------------------------
double hamiltonian(const double phi,const double p_phi) // p_phi = momentum
{
    double H;
    H =action(phi);
    H= H + 0.5*p_phi*p_phi;
    return H ;
}

// Find force , dS/dphi
double force(const double phi)
{
    double dS_dphi = phi;
    return dS_dphi;
}

//Evolve phi
int evolve(double& phi,double& H_i,double& H_f)
{
    int i;
    double p_phi;
    double dS;
    p_phi =gauss();
    
    // Calculating initial Hamiltonian H_i
    H_i = hamiltonian(phi, p_phi);
    
    // First Step of leap Frog METHOD
    phi =phi + 0.5*EPS*p_phi;
    
    //Step2,3,4,........,l
    for (i=1; i<=L; i++)
    {
        dS =force(phi);
        p_phi =p_phi -dS*EPS;
        phi = phi+p_phi*EPS;
    }
    

    //last step OF  LEAP FROG METHOD 
    dS = force(phi);
    p_phi = p_phi -dS*EPS;
    phi =phi +p_phi*0.5*EPS;
    
    // Calculate final hamiltonian H_f
    H_f = hamiltonian(phi,p_phi);
    
    return 0;
}

